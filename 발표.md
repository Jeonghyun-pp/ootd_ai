
  1. Next.js 16 (App Router) + React 19 + TypeScript

  실제 사용 확인:
  - App Router 기반 /ootd/page.tsx (메인 추천 페이지), /app/api/* (6개 API Routes)
  - React 19 hooks(useState, useEffect, useCallback)로 상태 관리
  - TypeScript로 ClosetItem, ClosetItemAttributes 등 도메인 타입 정의

  왜 이 기술을 선택했는가:

  ┌────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────┐
  │   선택 이유    │                                              설명                                              │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 풀스택 통합    │ 프론트엔드 UI + 백엔드 API Routes를 하나의 프로젝트에서 관리. ML 서버 호출, DB 쿼리,           │
  │                │ WeatherAPI 프록시를 모두 API Routes에서 처리하여 별도 백엔드 서버 불필요                       │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ SSR/SEO        │ App Router의 서버 컴포넌트로 초기 렌더링 성능 확보                                             │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 타입 안전성    │ DB 레이어(ClosetItem) → API 응답 → UI 컴포넌트(ClosetItemView)까지 End-to-End 타입 체크로      │
  │                │ 런타임 에러 최소화                                                                             │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ Vercel         │ Next.js 제작사인 Vercel에 제로 설정 배포. Edge Functions로 API Routes 자동 최적화              │
  │ 네이티브 배포  │                                                                                                │
  └────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────┘

  ---
  2. Tailwind CSS 4 + Shadcn/ui (Radix)

  실제 사용 확인:
  - Shadcn/ui 컴포넌트: Button, Card, Dialog, Input, Textarea, Badge (/src/components/ui/)
  - Tailwind 유틸리티 클래스로 그라데이션, 애니메이션, 반응형 레이아웃 구현
  - Sonner(토스트 알림), Lucide React(아이콘) 연동

  왜 이 기술을 선택했는가:

  ┌────────────────┬────────────────────────────────────────────────────────────────────────────────────────────────┐
  │   선택 이유    │                                              설명                                              │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 빠른 UI 개발   │ Shadcn/ui의 사전 제작된 접근성 완비 컴포넌트로 Dialog(업로드 폼), Card(옷장 아이템),           │
  │                │ Badge(카테고리 표시) 등을 빠르게 구현                                                          │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 커스터마이징   │ Shadcn/ui는 컴포넌트 코드를 직접 소유하므로 디자인 수정이 자유로움 (npm 패키지 의존 X)         │
  ├────────────────┼────────────────────────────────────────────────────────────────────────────────────────────────┤
  │ Tailwind 4     │ CSS-in-JS 대비 제로 런타임 오버헤드, 빌드 시 사용하지 않는 CSS 자동 제거                       │
  │ 성능           │                                                                                                │
  └────────────────┴────────────────────────────────────────────────────────────────────────────────────────────────┘

  ---
  3. Neon PostgreSQL + pgvector

  실제 사용 확인:
  - @neondatabase/serverless 클라이언트로 서버리스 연결 (neon-client.ts)
  - 3개 테이블: closet_items(옷장), recommendation_history(추천 이력), user_hyperparams(학습 파라미터)
  - pgvector: 512차원 벡터 저장, <=> 코사인 거리 연산자로 유사도 검색, IVFFlat 인덱스 적용

  왜 이 기술을 선택했는가:

  ┌──────────────────┬──────────────────────────────────────────────────────────────────────────────────────────────┐
  │    선택 이유     │                                             설명                                             │
  ├──────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 서버리스         │ Neon은 Vercel Edge Functions에서 직접 연결 가능한 서버리스 PostgreSQL. Connection pooling    │
  │ 아키텍처         │ 자동 관리로 콜드 스타트 최소화                                                               │
  ├──────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 벡터 검색 통합   │ pgvector로 관계형 데이터(속성)와 벡터 데이터(임베딩)를 하나의 DB에서 관리. 별도 벡터         │
  │                  │ DB(Pinecone, Weaviate) 불필요 → 인프라 단순화                                                │
  ├──────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 코사인 유사도    │ ORDER BY image_vector <=> query_vector로 이미지 임베딩 기반 유사 아이템 검색. IVFFlat        │
  │                  │ 인덱스로 대규모 데이터에서도 빠른 ANN(Approximate Nearest Neighbor) 검색                     │
  ├──────────────────┼──────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 하이퍼파라미터   │ user_hyperparams 테이블에서 추천 가중치를 영속적으로 관리. 피드백 시 eta * diff 업데이트로   │
  │ 학습             │ 온라인 학습 구현                                                                             │
  └──────────────────┴──────────────────────────────────────────────────────────────────────────────────────────────┘

  ---
  4. FastAPI + ONNX Runtime (Python ML 서버)

  실제 사용 확인:
  - 3개 엔드포인트: POST /recommend (추천), POST /analyze (이미지 분석), GET /health
  - 4단계 추천 파이프라인: 아이템 필터링 → 상하의 세트 매칭 → 이너 후보 → 아우터 매칭 + MMR
  - ONNX 모델: text_encoder.onnx(1.1MB), item_encoder.onnx(0.6MB), efficientnet_kfashion.onnx(16.4MB)
  - 색상 조화 알고리즘: LAB 색 공간에서 ΔE 거리 기반 조화 점수 산출

  왜 이 기술을 선택했는가:

  ┌────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────┐
  │     선택 이유      │                                            설명                                            │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ PyTorch → ONNX     │ PyTorch 컨테이너 6.6GB → ONNX 컨테이너 ~0.8GB로 약 88% 크기 절감. Railway 빌드 타임아웃    │
  │ 전환               │ 해결                                                                                       │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ CPU 추론 최적화    │ ONNX Runtime은 GPU 없이도 최적화된 추론 그래프 실행. Railway 무료 티어(CPU only)에서 운영  │
  │                    │ 가능                                                                                       │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ FastAPI 비동기     │ async/await 기반으로 동시 추천 요청 처리. Pydantic v2로 요청/응답 자동 검증                │
  │ 처리               │                                                                                            │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 관심사 분리        │ ML 로직을 Next.js에서 분리하여 독립적 스케일링, 배포, 모델 업데이트 가능                   │
  └────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────┘

  ---
  5. Cloudinary CDN

  실제 사용 확인:
  - /api/closet/upload에서 이미지를 Base64로 인코딩 후 Cloudinary 업로드
  - secure_url(HTTPS CDN URL)을 DB에 저장
  - closet 폴더에 타임스탬프 기반 public_id로 정리

  왜 이 기술을 선택했는가:

  ┌─────────────┬──────────────────────────────────────────────────────────────────────────────┐
  │  선택 이유  │                                     설명                                     │
  ├─────────────┼──────────────────────────────────────────────────────────────────────────────┤
  │ 글로벌 CDN  │ 이미지를 전 세계 엣지 서버에서 서빙. 사용자 위치와 가까운 서버에서 로딩      │
  ├─────────────┼──────────────────────────────────────────────────────────────────────────────┤
  │ 자동 최적화 │ 업로드 시 자동 포맷 변환(WebP/AVIF), 리사이징, 압축 지원                     │
  ├─────────────┼──────────────────────────────────────────────────────────────────────────────┤
  │ Vercel 호환 │ Next.js Image 컴포넌트와 연동 가능. DB에는 URL만 저장하여 스토리지 비용 분리 │
  ├─────────────┼──────────────────────────────────────────────────────────────────────────────┤
  │ 간편한 API  │ Base64 업로드 한 줄로 구현. S3 대비 SDK 설정이 훨씬 단순                     │
  └─────────────┴──────────────────────────────────────────────────────────────────────────────┘

  ---
  6. WeatherAPI.com

  실제 사용 확인:
  - /api/weather에서 WeatherAPI 프록시. 온도, 체감온도, 강수량, 날씨 상태 반환
  - 추천 시 temperature를 ML 서버에 전달 → 계절/날씨 기반 필터링에 사용
  - EfficientNet에서 7단계 날씨 카테고리 자동 추론 (폭염~한파)

  왜 이 기술을 선택했는가:

  ┌─────────────────┬───────────────────────────────────────────────────────────────────────────────────┐
  │    선택 이유    │                                       설명                                        │
  ├─────────────────┼───────────────────────────────────────────────────────────────────────────────────┤
  │ 실시간 컨텍스트 │ 현재 기온 기반으로 부적절한 의류 자동 필터링 (한여름에 패딩 X, 한겨울에 민소매 X) │
  ├─────────────────┼───────────────────────────────────────────────────────────────────────────────────┤
  │ 한국어 지원     │ lang=ko 파라미터로 날씨 상태 한국어 반환                                          │
  ├─────────────────┼───────────────────────────────────────────────────────────────────────────────────┤
  │ 무료 티어       │ 월 100만 호출 무료. 개인 프로젝트에 충분                                          │
  ├─────────────────┼───────────────────────────────────────────────────────────────────────────────────┤
  │ 간단한 REST API │ 단일 엔드포인트 호출로 필요한 모든 데이터 획득                                    │
  └─────────────────┴───────────────────────────────────────────────────────────────────────────────────┘

  ---
  7. Vercel (프론트 배포) + Railway (ML 배포) + Docker

  실제 사용 확인:
  - Dockerfile.ml: 멀티스테이지 빌드 (builder → runtime), python:3.10-slim 기반
  - Vercel: Next.js 자동 배포, Edge Functions로 API Routes 실행
  - Railway: Docker 컨테이너로 FastAPI 서버 호스팅

  왜 이 기술을 선택했는가:

  ┌────────────────────┬────────────────────────────────────────────────────────────────────────────────────────────┐
  │     선택 이유      │                                            설명                                            │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 최적 플랫폼 매칭   │ Vercel = Next.js 전용 최적화 플랫폼, Railway = Docker 컨테이너 전용 플랫폼. 각각의         │
  │                    │ 워크로드에 최적                                                                            │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 멀티스테이지       │ 빌드 의존성(pip install)과 런타임을 분리하여 최종 이미지 크기 최소화                       │
  │ Docker             │                                                                                            │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 독립 스케일링      │ 프론트엔드 트래픽과 ML 추론 부하를 독립적으로 스케일링 가능                                │
  ├────────────────────┼────────────────────────────────────────────────────────────────────────────────────────────┤
  │ 비용 효율          │ 둘 다 무료 티어 제공. 학생/사이드 프로젝트에 적합한 비용 구조                              │
  └────────────────────┴────────────────────────────────────────────────────────────────────────────────────────────┘

  ---
  아키텍처 다이어그램 (발표용)

  ┌─────────────────────────────────────────────────────────┐
  │                    사용자 (브라우저)                        │
  └──────────────────────┬──────────────────────────────────┘
                         │
                ┌────────▼────────┐
                │   Vercel Edge    │
                │  Next.js 16 SSR  │
                │  + API Routes    │
                └──┬───┬───┬───┬──┘
                   │   │   │   │
      ┌────────────┘   │   │   └────────────┐
      ▼                ▼   ▼                ▼
  ┌────────┐   ┌──────────────┐   ┌──────────────┐
  │Weather │   │    Neon DB    │   │  Cloudinary  │
  │API.com │   │  PostgreSQL   │   │    CDN       │
  │(날씨)   │   │  + pgvector   │   │  (이미지)    │
  └────────┘   └──────────────┘   └──────────────┘

                ┌──────────────┐
                │   Railway     │
                │  FastAPI +    │
                │  ONNX Runtime │
                │  (추천/분석)   │
                └──────────────┘

##DOCKER###################################################################
  ---
  멀티스테이지 빌드가 하는 일

  ┌─────────────────────────────────────┐
  │  Stage 1: Builder                   │
  │                                     │
  │  python:3.10-slim (~150MB)          │
  │  + pip, setuptools, wheel           │
  │  + gcc, build headers (일부 패키지)   │
  │  + requirements.txt install         │
  │                                     │
  │  → /opt/venv 에 패키지 설치 완료      │
  │  → 이 Stage는 최종 이미지에 포함 안 됨 │
  └──────────────┬──────────────────────┘
                 │ COPY --from=builder /opt/venv
                 ▼
  ┌─────────────────────────────────────┐
  │  Stage 2: Runtime (최종 이미지)       │
  │                                     │
  │  python:3.10-slim (~150MB)          │
  │  + /opt/venv (런타임 패키지만)        │
  │  + /app/app/ (FastAPI 코드)          │
  │  + /app/model/ (ONNX 모델)          │
  │                                     │
  │  빌드 도구, 캐시, 임시 파일 없음       │
  └─────────────────────────────────────┘

  핵심: Builder 스테이지의 pip 캐시, 빌드 도구, 컴파일 파일 등이 최종 이미지에 포함되지 않음

  ---
  PyTorch vs ONNX 이미지 크기 비교

  ┌────────────────┬──────────────────────────────────────────────────────┬─────────────────────┬──────┐
  │   구성 요소    │                     PyTorch 기반                     │      ONNX 기반      │ 절감 │
  ├────────────────┼──────────────────────────────────────────────────────┼─────────────────────┼──────┤
  │ Python 베이스  │ ~150MB                                               │ ~150MB              │ —    │
  ├────────────────┼──────────────────────────────────────────────────────┼─────────────────────┼──────┤
  │ ML 런타임      │ torch (~2GB) + timm (~500MB) + transformers (~400MB) │ onnxruntime (~60MB) │ ~97% │
  ├────────────────┼──────────────────────────────────────────────────────┼─────────────────────┼──────┤
  │ 모델 파일      │ .pt 파일 (~91MB)                                     │ .onnx 파일 (~111MB) │ 유사 │
  ├────────────────┼──────────────────────────────────────────────────────┼─────────────────────┼──────┤
  │ 기타 의존성    │ numpy, pillow, etc.                                  │ numpy, pillow, etc. │ 유사 │
  ├────────────────┼──────────────────────────────────────────────────────┼─────────────────────┼──────┤
  │ 총 이미지 크기 │ ~6.6GB                                               │ ~0.8GB              │ ~88% │
  └────────────────┴──────────────────────────────────────────────────────┴─────────────────────┴──────┘

  ---
  .dockerignore — 불필요한 파일 제외

  node_modules     # Next.js 프론트엔드 의존성 (ML과 무관)
  .next            # Next.js 빌드 캐시
  .git             # Git 히스토리
  __pycache__      # Python 캐시
  *.pyc            # 컴파일된 Python
  data/            # 로컬 데이터 (CSV 등)
  scripts/         # 변환 스크립트
  src/             # Next.js 소스코드 (ML과 무관)
  public/          # 정적 파일
  *.md             # 문서 파일
  .env*            # 환경변수 (비밀키 보호!)
  .claude/         # 개발 도구 설정

  효과: Docker 빌드 컨텍스트에서 프론트엔드 코드 전체를 제외하여 빌드 속도 향상 + 이미지 크기 절감

  ---
  Railway 배포 흐름

  git push → Railway 감지 → Dockerfile.ml 빌드
                                │
                      ┌─────────▼──────────┐
                      │ docker build        │
                      │ -f Dockerfile.ml .  │
                      │                    │
                      │ Stage 1: pip install│ ← 캐시 레이어 (변경 없으면 스킵)
                      │ Stage 2: COPY 코드  │ ← 코드 변경 시만 재빌드
                      └─────────┬──────────┘
                                │
                      ┌─────────▼──────────┐
                      │ Railway Container   │
                      │ PORT=8000           │
                      │ uvicorn app.main:app│
                      │ --host 0.0.0.0     │
                      └────────────────────┘

  ---
  Docker 레이어 캐싱 전략

  Dockerfile에서 변경 빈도가 낮은 것을 위에, 높은 것을 아래에 배치:

  COPY requirements.txt .          ← 거의 변경 안 됨 → 캐시 히트율 높음
  RUN pip install ...              ← requirements 변경 시만 재실행
    ...
  COPY ml-server/app/ ./app/       ← 코드 변경 빈번 → 맨 아래
  COPY model/ ./model/             ← 모델 업데이트 시만 재빌드

  requirements.txt를 소스코드보다 먼저 복사하므로, 코드만 수정한 경우 pip install을 다시 실행하지 않음 → 빌드 시간 대폭
  단축

  ---
  ${PORT:-8000} 환경변수 처리

  CMD uvicorn app.main:app --host 0.0.0.0 --port ${PORT:-8000}

  - Railway는 배포 시 PORT 환경변수를 자동 주입
  - :-8000: PORT가 없으면 기본값 8000 사용 (로컬 개발 시)
  - --host 0.0.0.0: 컨테이너 외부에서 접근 가능하도록 모든 인터페이스 바인딩

  ---
  발표용 한 줄 요약

  멀티스테이지 Docker 빌드로 PyTorch 6.6GB → ONNX 0.8GB (88% 절감)를 달성하고, 레이어 캐싱 전략으로 코드 변경 시 수십 초
   내 재배포가 가능한 경량 ML 컨테이너를 구축했습니다.
  ---
  핵심 차별점 요약 (발표 마무리용)

  1. ONNX 경량화: PyTorch 6.6GB → ONNX 0.8GB (88% 절감), GPU 없이 CPU 추론
  2. 단일 DB 벡터 검색: pgvector로 별도 벡터 DB 없이 코사인 유사도 검색
  3. 온라인 학습: 사용자 좋아요/싫어요 피드백으로 추천 가중치 실시간 업데이트
  4. LAB 색상 조화: 색 과학 기반의 의류 조합 점수 산출
  5. 서버리스 풀스택: Vercel Edge + Neon Serverless로 상시 서버 유지 불필요